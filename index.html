<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>YGO TCG PH Swiss (KTS Tie-breakers)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    h1 { margin: 0 0 12px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: start; }
    textarea, input, button, select { font-size: 14px; }
    textarea { width: 100%; height: 160px; }
    table { width: 100%; border-collapse: collapse; margin-top: 8px; }
    th, td { border: 1px solid #ddd; padding: 8px; }
    th { background: #f7f7f7; text-align: left; }
    .muted { color: #777; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eef; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; align-items:center; }
    .pair-card { border:1px solid #ddd; padding:12px; border-radius:12px; margin:8px 0 }
    .ok { color: #0a0; }
    .warn { color: #a60; }
    .error { color: #b00; }
  </style>
</head>
<body>
  <h1>üÉè YGO TCG PH Swiss (KTS Tie-breakers)</h1>

  <div class="row">
    <section>
      <h3>1) Participants</h3>
      <p>Paste names (one per line) or load a <code>.txt</code> file:</p>
      <textarea id="names"></textarea>
      <div class="controls">
        <input type="file" id="fileInput" accept=".txt" />
        <button id="loadBtn" disabled>Load Players</button>
        <span id="loadStatus" class="muted">Loading Python runtime‚Ä¶</span>
      </div>

      <h3 style="margin-top:24px;">2) Rounds</h3>
      <div class="controls">
        <label>Rounds: <input id="rounds" type="number" min="1" max="12" value="4" /></label>
        <button id="pairBtn" disabled>Pair Next Round</button>
        <button id="finalizeBtn" disabled>Finalize Round</button>
        <span id="roundStatus" class="pill">Round 0/0</span>
      </div>

      <div id="pairings"></div>
    </section>

    <section>
      <h3>Standings</h3>
      <div id="standings"></div>
    </section>
  </div>

  <script>
    // ------- ONE-TIME Pyodide loader with readiness gate -------
    const PYODIDE_VERSION = "0.24.1";
    let pyodide;

    const pyCode = `
from __future__ import annotations
from typing import List, Optional, Tuple
import random

class Player:
    POINTS_WIN = 3
    POINTS_TIE = 0
    POINTS_LOSS = 0
    def __init__(self, name: str):
        self.name: str = name
        self.wins: List[object] = []
        self.losses: List[object] = []
        self.ties: List[object] = []
        self.lost_rounds: List[int] = []
        self.tiebreaker: str = ""
    def get_points(self) -> int: return self.match_points()
    def num_wins(self) -> int: return len(self.wins)
    def num_losses(self) -> int: return len(self.losses)
    def num_byes(self) -> int: return sum(1 for w in self.wins if w == "BYE")
    def match_points(self) -> int:
        return self.POINTS_WIN*len(self.wins) + self.POINTS_TIE*len(self.ties) + self.POINTS_LOSS*len(self.losses)
    def matches_played_excl_bye(self) -> int:
        wins_excl_bye = sum(1 for w in self.wins if w != "BYE")
        return wins_excl_bye + len(self.losses) + len(self.ties)
    def wins_excl_bye(self) -> int:
        return sum(1 for w in self.wins if w != "BYE")
    def match_win_pct(self) -> float:
        denom = self.matches_played_excl_bye()
        return self.wins_excl_bye()/denom if denom else 0.0
    def opponents(self) -> List["Player"]:
        opps: List["Player"] = []
        for x in self.wins:
            if x != "BYE" and x not in opps: opps.append(x)  # type: ignore
        for x in self.losses:
            if x not in opps: opps.append(x)  # type: ignore
        for x in self.ties:
            if x not in opps: opps.append(x)  # type: ignore
        return opps

players: List[Player] = []
round_num: int = 0
total_rounds: int = 0
current_pairs: List[Tuple[Player, Optional[Player]]] = []

def suggested_rounds(n: int) -> int:
    if n <= 4: return 2
    if n <= 8: return 3
    if n <= 16: return 4
    if n <= 32: return 5
    if n <= 64: return 6
    if n <= 128: return 7
    return 8

def get_win_percentage(p: Player) -> float:
    wins = p.num_wins() - p.num_byes()
    losses = p.num_losses()
    return wins / (wins + losses) if (wins + losses) else 0.0

def get_opponents_win_percentage(p: Player) -> float:
    num, total = 0, 0.0
    for opp in p.wins + p.losses:
        if opp != "BYE":
            total += get_win_percentage(opp)
            num += 1
    return total / num if num else 0.0

def calculate_standings() -> None:
    for pl in players:
        pl.tiebreaker = str(pl.get_points())
        bbb_val = int(round(get_opponents_win_percentage(pl), 3) * 1000)
        bbb_val = max(0, min(999, bbb_val))
        pl.tiebreaker += str(bbb_val).zfill(3)
        num_opps, perc = 0, 0.0
        for opp in pl.wins + pl.losses:
            if opp != "BYE":
                perc += get_opponents_win_percentage(opp)
                num_opps += 1
        ccc_val = int(round(perc / num_opps, 3) * 1000) if num_opps else 0
        ccc_val = max(0, min(999, ccc_val))
        pl.tiebreaker += str(ccc_val).zfill(3)
        ddd_val = sum(r*r for r in pl.lost_rounds)
        ddd_val = min(999, ddd_val)
        pl.tiebreaker += str(ddd_val).zfill(3)

def check_pairings(pls: List[Player]) -> bool:
    seen = set()
    for p in pls:
        for opp in p.wins + p.losses:
            if opp == "BYE": continue
            pair = (min(p.name, opp.name), max(p.name, opp.name))
            if pair in seen: return False
            seen.add(pair)
    return True

def pair_round() -> None:
    global current_pairs, round_num
    players.sort(key=lambda x: -x.get_points())
    local = players[:]
    if len(local) % 2 != 0:
        lowest = local[-1]
        lowest.wins.append("BYE")
        local = local[:-1]
    def weight(pls): return sum(abs(pls[i].get_points()-pls[i+1].get_points()) for i in range(0,len(pls)-1,2))
    def loss_fn(pls):
        pen = weight(pls)
        for i in range(0,len(pls),2):
            if i+1 < len(pls):
                a,b = pls[i], pls[i+1]
                if b in a.wins or b in a.losses: pen += 1000
        return pen
    best = list(local)
    min_loss = loss_fn(local)
    improved = True
    while improved:
        improved = False
        for _ in range(max(1,len(local))*100):
            random.shuffle(local)
            score = loss_fn(local)
            if score < min_loss and check_pairings(local):
                min_loss = score
                best = list(local)
                improved = True
                break
    current_pairs = [(best[i], best[i+1]) for i in range(0,len(best),2)]
    round_num += 1

def api_init(names: list[str], rounds: int|None=None) -> dict:
    global players, round_num, total_rounds, current_pairs
    players = [Player(n) for n in names]
    round_num = 0
    total_rounds = rounds if rounds and rounds>0 else suggested_rounds(len(players))
    current_pairs = []
    calculate_standings()
    return { "round": round_num, "total_rounds": total_rounds }

def api_pair_next() -> list[list[str]]:
    pair_round()
    return [[a.name, b.name] for (a,b) in current_pairs]

def api_finalize(results: list[str]) -> None:
    for i, outcome in enumerate(results):
        a, b = current_pairs[i]
        if outcome == "A":
            a.wins.append(b); b.losses.append(a); b.lost_rounds.append(round_num)
        elif outcome == "B":
            b.wins.append(a); a.losses.append(b); a.lost_rounds.append(round_num)
        elif outcome == "TIE":
            a.losses.append(b); b.losses.append(a)
            a.lost_rounds.append(round_num); b.lost_rounds.append(round_num)
    calculate_standings()

def api_standings() -> list[dict]:
    calculate_standings()
    rows = []
    for p in sorted(players, key=lambda x: -int(x.tiebreaker)):
        denom = p.matches_played_excl_bye()
        mw = (p.wins_excl_bye()/denom*100.0) if denom else 0.0
        omw = get_opponents_win_percentage(p)*100.0
        num_opps, perc = 0, 0.0
        for opp in p.wins + p.losses:
            if opp != "BYE":
                perc += get_opponents_win_percentage(opp)
                num_opps += 1
        oomw = (perc/num_opps*100.0) if num_opps else 0.0
        ddd = str(sum(r*r for r in p.lost_rounds)).zfill(3)
        rows.append({"Player": p.name, "Pts": p.get_points(), "MW%": f"{mw:0.1f}",
                     "OMW%": f"{omw:0.1f}", "OOMW%": f"{oomw:0.1f}", "DDD": ddd, "KTS": p.tiebreaker})
    for i,r in enumerate(rows, start=1): r["Rank"]=i
    return rows
`;

    // Promise that resolves when Python runtime is fully ready
    const pyReady = (async () => {
      try {
        // load loader
        const s = document.createElement("script");
        s.src = `https://cdn.jsdelivr.net/pyodide/v${PYODIDE_VERSION}/full/pyodide.js`;
        document.head.appendChild(s);
        await new Promise((res, rej) => { s.onload = res; s.onerror = rej; });
        // init runtime + preload code
        pyodide = await loadPyodide({ indexURL: `https://cdn.jsdelivr.net/pyodide/v${PYODIDE_VERSION}/full/` });
        await pyodide.runPythonAsync(pyCode);
        return true;
      } catch (e) {
        console.error(e);
        document.getElementById("loadStatus").textContent = "Failed to load Python runtime.";
        document.getElementById("loadStatus").className = "error";
        return false;
      }
    })();

    // ------- DOM helpers -------
    const $ = (id) => document.getElementById(id);

    function standingsTable(rows){
      if (!rows || !rows.length) return "<p class='muted'>No standings yet</p>";
      let html = "<table><thead><tr><th>Rank</th><th>Player</th><th>Pts</th><th>MW%</th><th>OMW%</th><th>OOMW%</th><th>DDD</th><th>KTS</th></tr></thead><tbody>";
      for(const r of rows){
        html += `<tr><td>${r.Rank}</td><td>${r.Player}</td><td>${r.Pts}</td><td>${r["MW%"]}</td><td>${r["OMW%"]}</td><td>${r["OOMW%"]}</td><td>${r.DDD}</td><td>${r.KTS}</td></tr>`;
      }
      html += "</tbody></table>";
      return html;
    }

    let currentPairs = [];
    let resultSelects = [];

    function pairingsUI(pairs){
      if (!pairs || !pairs.length) return "<p class='muted'>No active pairings. Click <b>Pair Next Round</b>.</p>";
      let html = "";
      pairs.forEach((p, i) => {
        html += `
          <div class="pair-card">
            <b>Table ${i+1}</b><br/>
            ${p[0]} vs ${p[1]}<br/>
            <label><input type="radio" name="t${i}" value="A"> ${p[0]} wins</label>
            <label><input type="radio" name="t${i}" value="B"> ${p[1]} wins</label>
            <label><input type="radio" name="t${i}" value="TIE"> Tie</label>
          </div>`;
      });
      return html;
    }

    async function refreshStandings(){
      const rows = await pyodide.runPythonAsync("api_standings()");
      $("standings").innerHTML = standingsTable(rows.toJs());
    }

    function updateRoundPill(round,total){
      $("roundStatus").textContent = `Round ${round}/${total}`;
    }

    // ------- Wire up UI once runtime is ready -------
    (async () => {
      const ok = await pyReady;
      if (ok) {
        $("loadStatus").textContent = "Python runtime ready.";
        $("loadStatus").className = "muted";
        $("loadBtn").disabled = false;
      }

      $("fileInput").addEventListener("change", async (e)=>{
        const f = e.target.files?.[0];
        if(!f) return;
        const text = await f.text();
        $("names").value = text;
      });

      $("loadBtn").addEventListener("click", async ()=>{
        try {
          $("loadBtn").disabled = true;
          $("loadStatus").textContent = "Initializing players‚Ä¶";
          const names = $("names").value.split("\n").map(s=>s.trim()).filter(Boolean);
          if(!names.length){ $("loadStatus").textContent = "Add at least one name."; $("loadBtn").disabled = false; return; }
          const rounds = parseInt($("rounds").value,10) || 0;
          const ret = await pyodide.runPythonAsync(`api_init(${JSON.stringify(names)}, ${rounds})`);
          const obj = ret.toJs();
          updateRoundPill(obj.round, obj.total_rounds);
          $("loadStatus").textContent = `Loaded ${names.length} players.`;
          $("pairBtn").disabled = false;
          $("finalizeBtn").disabled = true;
          $("pairings").innerHTML = "<p class='muted'>Ready to pair.</p>";
          await refreshStandings();
        } catch (e) {
          console.error(e);
          $("loadStatus").textContent = "Error: see console";
          $("loadStatus").className = "error";
        } finally {
          $("loadBtn").disabled = false;
        }
      });

      $("pairBtn").addEventListener("click", async ()=>{
        try {
          $("pairBtn").disabled = true;
          $("finalizeBtn").disabled = true;
          const pairs = await pyodide.runPythonAsync("api_pair_next()");
          currentPairs = pairs.toJs();
          $("pairings").innerHTML = pairingsUI(currentPairs);
          resultSelects = [];
          currentPairs.forEach((_, i)=>{
            resultSelects[i] = Array.from(document.querySelectorAll(`input[name="t${i}"]`));
          });
          const obj = (await pyodide.runPythonAsync("{'r': round_num, 't': total_rounds}")).toJs();
          updateRoundPill(obj.r, obj.t);
          $("finalizeBtn").disabled = false;
        } catch (e) {
          console.error(e);
          $("loadStatus").textContent = "Pairing failed (see console).";
          $("loadStatus").className = "error";
          $("pairBtn").disabled = false;
        }
      });

      $("finalizeBtn").addEventListener("click", async ()=>{
        // collect results
        const res = [];
        for(let i=0;i<currentPairs.length;i++){
          const sel = document.querySelector(`input[name="t${i}"]:checked`);
          if(!sel){ alert(`Please enter result for table ${i+1}.`); return; }
          res.push(sel.value);
        }
        await pyodide.runPythonAsync(`api_finalize(${JSON.stringify(res)})`);
        await refreshStandings();
        $("pairings").innerHTML = "<p class='ok'>Round finalized. Pair next round when ready.</p>";
        $("pairBtn").disabled = false;
        $("finalizeBtn").disabled = true;
      });
    })();
  </script>
</body>
</html>
